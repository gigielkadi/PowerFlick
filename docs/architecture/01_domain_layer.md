# PowerFlick — Domain Layer Rules (v1.0)

These rules tailor the generic domain‑layer conventions to **PowerFlick**, the energy‑management system built with Flutter + Supabase.  
The domain layer must contain **pure Dart** code only: no Flutter widgets, Supabase SDKs, or external IO.  

---

## 1  Directory Structure
```
lib/
  └── powerflick/
      └── <context>/          # e.g. energy, user, automation
          └── domain/
              ├── models/     # ❯ device_model.dart, reading_model.dart …
              ├── services/   # ❯ i_device_service.dart …
              ├── errors/     # ❯ device_error.dart
              └── value_objects/
```

---

## 2  Model Conventions

| Rule | Explanation |
|------|-------------|
| **Immutability** | All models are `const` & use the **Freezed** package. |
| **Empty ctor** | Provide default values so `DeviceModel()` is always valid. |
| **Value Objects** | Wrap primitives where meaning matters (`KilowattHour`, `Watt`, `UtcTimestamp`). |
| **Docs** | Every property has a `///` comment (appears in IDE tooltips). |
| **No dynamic** | Use rich types or generics—never `dynamic`. |
| **Validation** | Create `validate()` inside `@Assert` or factory to keep invariants. |

### Sample
```dart
@freezed
class DeviceModel with _$DeviceModel {
  const factory DeviceModel({
    /// UUID generated by Supabase
    @Default('') String id,
    /// Human‑readable name (e.g., 'Kitchen Fridge')
    @Default('') String label,
    /// Current connection state
    @Default(DeviceConnection.offline) DeviceConnection connection,
    /// Watt rating declared by user
    @Default(0) int wattRating,
  }) = _DeviceModel;
}

enum DeviceConnection { online, offline }
```

---

## 3  Service / Interface Conventions

### 3.1 Structure & Naming
* Interfaces live under `services/`, start with `I`, end with `Service`.  
  *Example:* `i_device_service.dart` → `IDeviceService`.
* Return `Result<T, E>` (`result_type` ^0.0.1) for any fallible op.

### 3.2 Method Rules
| Aspect | Guideline |
|--------|-----------|
| **Async** | All IO/DB calls return `Future<Result<…>>`. |
| **Clarity** | Verb‑based names (`fetchDevice`, `createReading`). |
| **Errors** | Fail branch uses an **error union** from `errors/`. |
| **Docs** | List each error type in the dart‑doc. |

#### Sample
```dart
import 'package:result_type/result_type.dart';

abstract class IDeviceService {
  /// Fetch a device by Supabase id.
  ///
  /// * **DeviceError.notFound** – No row in DB.
  Future<Result<DeviceModel, DeviceError>> fetchDevice(String id);

  /// Register a new device in a given room.
  ///
  /// * **DeviceError.validation** – Bad label or duplicate.
  Future<Result<DeviceModel, DeviceError>> createDevice({
    required String roomId,
    required DeviceModel draft,
  });
}
```

---

## 4  Error & Exception Handling
* One sealed `DeviceError` per context, using `freezed`.  
* Map Supabase exceptions inside infra layer → domain errors; domain layer **never** sees SQL codes.

---

## 5  File & Class Naming
| Element | Rule |
|---------|------|
| **Model file** | `device_model.dart` (snake) |
| **Service file** | `i_device_service.dart` |
| **Value object** | `kilowatt_hour.dart` |

---

## 6  Testing Guidelines
```
test/
  └── powerflick/
      └── <context>/
          └── domain/
              ├── device_model_test.dart
              └── device_service_test.dart
```
* Test **default ctor**, `copyWith`, equality, and validation.
* Verify `Result.success` vs. `Result.failure` branches.

---

## 7  Best‑Practice Checklist
- [ ] Each model has `const factory` + defaults.
- [ ] No reference to Supabase, Flutter, or platform IoC.
- [ ] All services use `Result<T,E>`.
- [ ] Public APIs fully documented.
- [ ] Tests cover ≥ 90 % of model & service logic. 